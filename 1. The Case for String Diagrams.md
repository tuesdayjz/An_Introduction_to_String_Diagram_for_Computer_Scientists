## The algebric structure of programs

- プログラミング言語を学習するとき、一番基本的なタスクとしてはその言語のシンタックスに従って正しくプログラムを書くこと
- シンタックスは、しばしば文脈自由文法として定められる
- 例えば $x, y, ...$ と $n\in\mathbf{N}$ が出現するような初等的な命令形言語を考えたとき、**文法(1)** を定めるシンタックスは以下：
$$\begin{aligned}
b \quad &::=\quad True \quad | \quad x=y \quad | \quad \lnot b\quad | \quad b\land b \quad | \quad b\lor b\\
p \quad &::=\quad skip \quad | \quad x:=y \quad | \quad x := n\quad | \quad while\;b\;do\;p \quad | \quad p;p\\
\end{aligned}$$
- 代入、while ループ、プログラムの継続がかける
　- $b$ は ブール式
- この情報は、実装する人にとっては正しくコードを書くために必須
　- プログラムの形式的な分析に興味があるコンピュータサイエンティストにとっては、言語の数学的な性質を証明するためのパワフルなツール
- たとえば自然数について推論するとき、自然数は以下のような文法(2)で指定できる
$$n\quad ::=\quad 0\quad|\quad n+1$$
- 文法(2)を使えば帰納的に算術演算の定義と性質の証明ができる
	- base case と inductive step が文法の節に正確に対応する
- 例えば、for each $n\in\mathbf{N},\;n-n=0$ が言える
	- $n=0$ のとき $0-0=0$
	- $m\in\mathbf{N}$ で正しいとき $(m+1)-(m+1)=(m-m)+(1-1)=0+0=0$ 
		- でもこれ加減の意味論まだ決めてないじゃんと思ったけど流石にそれはある前提なのか？

- 文法（シンタックス）があるおかげで、こんな感じでプログラムも正確に帰納的に推論できる
- 例えば、文法(1)で定められたプログラムで性質 $P$ が成り立つことが示せる
	- $P$ が $skip,\;x:=y,\;x:=a$ で成り立つと示す
	- $P$ が $p$ で成り立つと仮定したとき、$while\;b\;do\;p$ でも成り立つと示す
	- $P$ が $p,\;p'$ で成り立つとき $p;p'$ でも成り立つと示す

- この方法っていろんなときに使える
-  例えば、プログラムの $correctness,\;safety,\;liveness$ とかの性質を示せる
- セマンティクスも帰納的に定義できる
	- 構造に基づいてプログラムに動作を割り当てる
- プログラミング言語の理論では、セマンティクスを定義するのに2つの方法がある
	1. 操作的意味論
		- 直接、どうやってそれぞれの式を実行するのかを指定する
	2. 表示的意味論
		- してほしい動作を抽象化する数学的なオブジェクトを式に割り当てる
- 帰納的に定義されたセマンティクスは、$compositional\;(modular,\;構成的)$ な推論を可能にするので特に重要
	- 複雑なプログラムを、もっと初等的な式のセマンティクスの意味から完全に理解できる場合がある
- 例えば、セマンティクスが、$p$ は 関数 $[p]$ で $p;p'$ は $[p']\circ[p]$ だと決めてくれているとき、
	- $p\;;\;p'$ の式のセマンティクスは $exclusive$ に、より単純な式 $p,\;p'$ に依存する

- 更に、構成的な意味論を持っている構文として言語を記述することは、プログラムの設計の基礎になっている代数的な構造を教えてくれる
- 例えば、どんなセマンティクスでも、文法(1)のプログラムの構成子 $;$ と $skip$ は、二項演算子 $;$ を乗算として定数 $skip$ を $identity\;element$ とする $monoid$ 構造を獲得する
	- モノイドとは、連想的な二項演算のもとで閉じていて、全ての $a\in S$ に対して $Ia=aI=a$ となるような恒等要素 $I\in S$ を持つ集合のこと、らしい
	- https://mathworld.wolfram.com/Monoid.html
		- commutative monoid とかいうのもある
		- https://mathworld.wolfram.com/CommutativeMonoid.html
		- https://ncatlab.org/nlab/show/commutative+monoid
- つまり、$[(p;q);r]=[p;(q;r)]\;(associability),\;[p;skip]=[p]=[skip;p]\;(unitality)$ が常に成り立つ

## Graphical models of Computation

- このような感じで、帰納的に定義されたシンタックスによって形式言語を定義することには明確な利点がある。
- しかし、全ての計算の現象がこのような形式論で適切に捉えられるとは限らない
	- デジタルコントローラーを流れる信号
		- 情報は構成子を複雑な方法で伝搬するし、リソースの処理方法に制限がある
			- ゲートが一度に受け取れる信号の量が決まってたり
			- デッドロックが起きたり
	- より洗練されたインタラクションも...
		- 量子プロセスのもつれ
		- 確率的なシステムにおける変数間の条件付き（非）依存性
- 構成子の間の資源交換を明確で表現的に捉えられる言語が必要

- 歴史的には、こういった現象を適切に視覚化して推論するために、グラフィカルな形式主義を採用してきた
- グラフは component-based なシステムでの情報の流れをシンプルな絵で表現する
- これは従来のテキスト方式では困難
	- デジタル回路
	- 量子回路
	- signal flow graph（制御理論）
	- ペトリネット（並行性理論）
	- 確率的グラフモデル
		- bayesian network
		- factor graph
		- ニューラルネットワーク

- 一方で、 グラフィカルモデルは構文的に定義された形式言語と比べて明らかな欠点がある
- グラフみたいな組み合わせの構造は数学的に推論しにくい
- モデルの構成要素に対しては、普通のプログラムでするような帰納法が使えない
	- シンタックスはシンプルなものを組み合わせて複雑なものにするのに演算子を使う
	- グラフはモジュール的ではなくて、モノリシックな実体として扱われがち
	- グラフを分解したりくっつけたりする形式的な手段を見失いやすい
- グラフィカルな形式主義の上では、プログラム解析の重要な特徴は障害に直面する
	- 構成的なセマンティクスの定義
	- 代数的な構造の調査
- ラッキーなことにシンタックスとグラフィカルな表現を2つに分けてしまうことには本質的な意味はない